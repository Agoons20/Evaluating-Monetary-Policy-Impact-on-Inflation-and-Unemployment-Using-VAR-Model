{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5c8dbcc-1a3a-416b-bb35-d857d4087fae",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from statsmodels.tsa.stattools import grangercausalitytests\n",
    "import os\n",
    "\n",
    "def calculate_forecast_metrics(forecast, actual, columns=None):\n",
    "    \"\"\"\n",
    "    Calculate forecast accuracy metrics for each variable in the forecasted and actual data.\n",
    "\n",
    "    Parameters:\n",
    "    - forecast: pandas DataFrame or NumPy array, forecasted values with shape (n, k)\n",
    "    - actual: pandas DataFrame or NumPy array, actual values with the same shape as forecast\n",
    "    - columns: list, optional, names of the variables (required if inputs are NumPy arrays)\n",
    "\n",
    "    Returns:\n",
    "    - dict: Dictionary with metrics (ME, MAE, MPE, MAPE, RMSE) for each variable\n",
    "    \"\"\"\n",
    "    if isinstance(forecast, np.ndarray):\n",
    "        if columns is None:\n",
    "            raise ValueError(\"Column names must be provided if forecast is a NumPy array\")\n",
    "        forecast = pd.DataFrame(forecast, columns=columns)\n",
    "    if isinstance(actual, np.ndarray):\n",
    "        if columns is None:\n",
    "            raise ValueError(\"Column names must be provided if actual is a NumPy array\")\n",
    "        actual = pd.DataFrame(actual, columns=columns)\n",
    "\n",
    "    actual = actual[forecast.columns].copy()\n",
    "    forecast_values = forecast.values\n",
    "    actual_values = actual.values\n",
    "    actual_values[actual_values == 0] = 0.0001\n",
    "\n",
    "    me = np.mean(forecast_values - actual_values, axis=0)\n",
    "    mae = np.mean(np.abs(forecast_values - actual_values), axis=0)\n",
    "    mpe = np.mean((forecast_values - actual_values) / actual_values, axis=0)\n",
    "    mape = np.mean(np.abs(forecast_values - actual_values) / np.abs(actual_values), axis=0)\n",
    "    rmse = np.sqrt(np.mean((forecast_values - actual_values) ** 2, axis=0))\n",
    "\n",
    "    metrics = {}\n",
    "    for i, col in enumerate(forecast.columns):\n",
    "        metrics[col] = {\n",
    "            'ME': me[i],\n",
    "            'MAE': mae[i],\n",
    "            'MPE': mpe[i],\n",
    "            'MAPE': mape[i],\n",
    "            'RMSE': rmse[i]\n",
    "        }\n",
    "    return metrics\n",
    "\n",
    "def perform_analysis(results, train, test, df_fc, df):\n",
    "    \"\"\"\n",
    "    Visualizes forecasts, evaluates metrics, performs Granger Causality tests, and concludes the analysis.\n",
    "    Saves outputs to results/.\n",
    "    \"\"\"\n",
    "    # Ensure the output directories exist\n",
    "    os.makedirs(\"results/plots\", exist_ok=True)\n",
    "    os.makedirs(\"results/analysis\", exist_ok=True)\n",
    "\n",
    "    # Add 'fedrate' to train, test, and df_fc\n",
    "    train['fedrate'] = df['fedrate'][1:-8]\n",
    "    test['fedrate'] = df['fedrate'][-8:]\n",
    "    last_fedrate = train['fedrate'].iloc[-1]\n",
    "    df_fc['fedrate'] = last_fedrate + df_fc['dfedrate'].cumsum()\n",
    "\n",
    "    # Task 17: Visualize forecasts vs actuals for all three variables\n",
    "    variables = ['unempgr', 'dfedrate', 'inflat', 'fedrate']\n",
    "    titles = {\n",
    "        'unempgr': 'Forecast vs Actuals for Unemployment Growth Rate',\n",
    "        'dfedrate': 'Forecast vs Actuals for Differenced Federal Funds Rate',\n",
    "        'inflat': 'Forecast vs Actuals for Inflation Rate',\n",
    "        'fedrate': 'Forecast vs Actuals for Federal Funds Rate'\n",
    "    }\n",
    "    y_labels = {\n",
    "        'unempgr': 'Unemployment Growth Rate (%)',\n",
    "        'dfedrate': 'Percentage Change',\n",
    "        'inflat': 'Inflation Rate (%)',\n",
    "        'fedrate': 'Federal Funds Rate (%)'\n",
    "    }\n",
    "\n",
    "    for var in variables:\n",
    "        plt.figure(figsize=(12, 5), dpi=100)\n",
    "        plt.plot(train[var][-40:], label='Training', color='blue')\n",
    "        plt.plot(test[var], label='Actual', color='green')\n",
    "        plt.plot(df_fc[var], label='Forecast', color='red')\n",
    "        plt.title(titles[var])\n",
    "        plt.xlabel('Date')\n",
    "        plt.ylabel(y_labels[var])\n",
    "        plt.legend(loc='upper left', fontsize=10)\n",
    "        plt.grid(True, linestyle='--', alpha=0.7)\n",
    "        plt.savefig(f\"results/plots/forecast_vs_actuals_{var}.png\")\n",
    "        plt.close()\n",
    "\n",
    "    # Task 18: Evaluate the forecast\n",
    "    fc_subset = df_fc[['unempgr', 'dfedrate', 'inflat']]\n",
    "    test_subset = test[['unempgr', 'dfedrate', 'inflat']]\n",
    "    metrics = calculate_forecast_metrics(fc_subset, test_subset)\n",
    "\n",
    "    # Save forecast metrics\n",
    "    with open(\"results/analysis/forecast_metrics.txt\", \"w\") as f:\n",
    "        f.write(\"Forecast Accuracy Metrics:\\n\\n\")\n",
    "        for var, values in metrics.items():\n",
    "            f.write(f\"{var}:\\n\")\n",
    "            f.write(f\"  ME: {values['ME']:.4f}\\n\")\n",
    "            f.write(f\"  MAE: {values['MAE']:.4f}\\n\")\n",
    "            f.write(f\"  MPE: {values['MPE']:.4f}\\n\")\n",
    "            f.write(f\"  MAPE: {values['MAPE']:.4f}\\n\")\n",
    "            f.write(f\"  RMSE: {values['RMSE']:.4f}\\n\\n\")\n",
    "\n",
    "    # Task 19: Granger Causality Tests\n",
    "    # dfedrate -> unempgr\n",
    "    df_gc1 = pd.DataFrame({'dfedrate': train['dfedrate'], 'unempgr': train['unempgr']})\n",
    "    gc_results_1 = grangercausalitytests(df_gc1, 2, verbose=False)\n",
    "    with open(\"results/analysis/granger_causality_dfedrate_unempgr.txt\", \"w\") as f:\n",
    "        for lag, result in gc_results_1.items():\n",
    "            f.write(f\"\\nGranger Causality (dfedrate -> unempgr), Lag {lag}\\n\")\n",
    "            for test, stats in result[0].items():\n",
    "                f.write(f\"{test}: {stats}\\n\")\n",
    "\n",
    "    # dfedrate -> inflat\n",
    "    df_gc2 = pd.DataFrame({'dfedrate': train['dfedrate'], 'inflat': train['inflat']})\n",
    "    gc_results_2 = grangercausalitytests(df_gc2, 2, verbose=False)\n",
    "    with open(\"results/analysis/granger_causality_dfedrate_inflat.txt\", \"w\") as f:\n",
    "        for lag, result in gc_results_2.items():\n",
    "            f.write(f\"\\nGranger Causality (dfedrate -> inflat), Lag {lag}\\n\")\n",
    "            for test, stats in result[0].items():\n",
    "                f.write(f\"{test}: {stats}\\n\")\n",
    "\n",
    "    # unempgr -> inflat\n",
    "    df_gc3 = pd.DataFrame({'unempgr': train['unempgr'], 'inflat': train['inflat']})\n",
    "    gc_results_3 = grangercausalitytests(df_gc3, 2, verbose=False)\n",
    "    with open(\"results/analysis/granger_causality_unempgr_inflat.txt\", \"w\") as f:\n",
    "        for lag, result in gc_results_3.items():\n",
    "            f.write(f\"\\nGranger Causality (unempgr -> inflat), Lag {lag}\\n\")\n",
    "            for test, stats in result[0].items():\n",
    "                f.write(f\"{test}: {stats}\\n\")\n",
    "\n",
    "    # Task 20: Conclusion\n",
    "    conclusion = \"\"\"\n",
    "Conclusion:\n",
    "- The VAR model captured bidirectional relationships (e.g., differenced fedrate lending rates affects unemployment growth rate, and unemployment growth rate affects differenced fedrate lending rates), but it doesnâ€™t explicitly test which direction is statistically significant. Granger Causality tests provide this directional insight showing that differenced fedrate lending rates Granger-causes unemployment growth rate (p < 0.001), meaning past changes in the federal funds rate are useful for predicting unemployment growth. This supports the idea that monetary policy impacts unemployment. Thus, to address high levels of unemployment, the Federal Reserve should consider lowering interest rates or increasing the money supply to stimulate spending and encourage hiring.\n",
    "\n",
    "- The lack of Granger Causality from differenced fedrate lending rates to inflation challenges the recommendation to raise rates to combat inflation, as the model suggests limited predictive power in this direction. This finding aligns with the VAR results, where differenced federal lending rate unexpectedly increased inflation, prompting the need for a structural VAR (SVAR) to capture contemporaneous effects.\n",
    "\"\"\"\n",
    "    with open(\"results/conclusion.txt\", \"w\") as f:\n",
    "        f.write(conclusion)\n",
    "\n",
    "    return None\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    from import_data import import_data\n",
    "    from merge_data import merge_data\n",
    "    from feature_engineering import feature_engineering\n",
    "    from stationarity_check import check_stationarity\n",
    "    from var_model import fit_var_model\n",
    "    unemp_q, inflat_q, fedfund_q = import_data()\n",
    "    df = merge_data(unemp_q, inflat_q, fedfund_q)\n",
    "    df = feature_engineering(df)\n",
    "    stationary_df = check_stationarity(df)\n",
    "    results, train, test, df_fc = fit_var_model(stationary_df)\n",
    "    perform_analysis(results, train, test, df_fc, df)\n",
    "    print(\"Analysis completed\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
